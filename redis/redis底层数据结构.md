## 参考
- https://blog.csdn.net/chenssy/article/details/103856180


## 简单动态字符串（simple dynamic string,SDS）
```c
struct sdshdr{
//记录buf数据中已使用字节数据
//等于SDS所保存字符串的长度
 int len;

//记录buf数组中未使用字节的数量
int free;

//字节数组，用于保存字符串
char buf[];
}
```
redis没有直接使用C语言的字符串，而是使用了自己创建的简单动态字符串的数据结构，包含三个字段：`已使用长度`，`未使用长度`，`字节数组`
### 好处
- 获取字符串长度时间复杂度为`O(1)`,而c语言则需要`O(N)`
- 防止缓冲区溢出，C字符串不记录自身长度，如果在做字符串扩大的操作，如果事先没有为其设置足够的内存空间，则会引起内存溢出的情况，而`sds`则会根据`sds.len`判断是否有足够的空间，如果不够大，则先进行扩容，然后再写入内容
- 二进制安全，例如C语言字符串里不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、书品、压缩文件这样的二进制数据

## 链表
```c
typedef  struct listNode{
       //前置节点
       struct listNode *prev;
       //后置节点
       struct listNode *next;
       //节点的值
       void *value;  
}listNode
```
链表有`prev`,`next`前后指针，可以进行双向遍历；`head`,`tail`头尾两个指针可以实现头尾插入的复杂度为`O(1)`


## 字典
一种用于保存键值对的抽象数据结构，redis的字典使用哈希表作为底层实现，每个字典通常有两个哈希表，一个平时使用，另一个用于rehash时使用；随着数据量的不断增加，数据必然会发生`hash冲撞`，使用链地址法解决哈希冲突
还有一个`rehash`过程，渐进式rehash的好处是它采取分而治之的方式，将rehash键值所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash带来的庞大计算量

每个字典包含两个`hashtable`，一个用于正常的读写，一个用于哈希表`rehash`的临时载体

扩容的条件
负载因子 = 哈希表保存的key的数量 / 哈希表的大小

![https://upload-images.jianshu.io/upload_images/1760830-aaddd201d3dd238c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1061/format/webp](https://upload-images.jianshu.io/upload_images/1760830-aaddd201d3dd238c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1061/format/webp)

### 如何解决哈希冲突
- 开放地址法
- 链地址法


## 跳跃表
跳跃表是一种基于有序链表的扩展，表中的节点按照分值大小进行排序。为了加速搜索，每个的节点会通过抛硬币的方法选择是否往上一层建立索引，最终构建成一个分层链表结构，搜索的方式是从左到右，从高层到低层
### 特点
- 每个节点维护多个指向其他节点的指针
- 多层结构，每一层都是一个有序链表，最底层链表保存所有元素和分值
- 链表中两个节点包括两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点
总体上，跳跃表插入操作的时间复杂度是O（logN），而这种数据结构所占空间是2N，既空间复杂度是 O（N）
### 跳跃表和二叉查找树的区别
跳跃表的优点是维持结构平衡的成本比较低，完全依靠随机，而二叉查找树在多次插入删除后，需要rebalance来重新调整结构平衡
https://www.jianshu.com/p/dc252b5efca6


## 整数集合
整数集合（intset）是Redis用于保存整数值的集合抽象数据类型，它可以保存类型为int16_t、int32_t 或者int64_t 的整数值，并且保证集合中不会出现重复元素


## 压缩列表
https://www.jianshu.com/p/d9ac7074f10e
ziplist 将表中每一项存放在前后连续的地址空间内，相对于链表，压缩列表占用一块连续内存	
### 原理
```bash
<zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>
```
- zlbytes：表示这个ziplist占用了多少空间，或者说占了多少字节，这其中包括了zlbytes本身占用的4个字节；
- zltail：表示到ziplist中最后一个元素的偏移量，有了这个值，pop操作的时间复杂度就是O(1)了，即不需要遍历整个ziplist；
- zllen：表示ziplist中有多少个entry，即保存了多少个元素。由于这个字段占用16个字节，所以最大值是2^16-1，也就意味着，如果entry的数量超过2^16-1时，需要遍历整个ziplist才知道entry的数量；
- entry：真正保存的数据，有它自己的编码；
- zlend：专门用来表示ziplist尾部的特殊字符，占用8个字节，值固定为255，即8个字节每一位都是1。
压缩列表每个节点构成：
![https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180528223605060-899108663.png](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180528223605060-899108663.png)

### 压缩列表带来的问题
ziplist将数据按照一定规则编码在一块连续的内存区域，目的是节省内存，这种结构并不擅长做修改操作。一旦数据发生改动，就会引发内存realloc，可能导致内存拷贝

双向链表linkedlist便于在表的两端进行push和pop操作，在插入节点上复杂度很低，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。
ziplist存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝。

## 快速列表
`quickList`是有`ziplist`组成的双端列表，即每个节点都是一个`ziplist`


