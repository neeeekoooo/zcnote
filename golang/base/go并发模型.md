## 参考
- https://segmentfault.com/a/1190000015464889#articleHeader14

## 1. 线程模型主要有三种
### 1.1 用户级线程模型
操作系统只知道用户进程而对其中的线程是无感知的，内核的所有调度都是基于用户进程。许多语言实现的 协程库 基本上都属于这种方式（比如python的gevent）,不需要让CPU在用户态和内核态之间切换
缺点: 当某个用户进程上的某个用户线程因为一个阻塞调用（比如I/O阻塞）而被CPU给中断（抢占式调度）了，那么该进程内的所有线程都被阻塞. 所以很多的协程库会把自己一些阻塞的操作重新封装为完全的非阻塞形式

### 1.2 内核级线程模型
每一个用户线程绑定一个实际的内核线程; 由系统调度,CPU可以快速切换调度线程

### 1.3 两级线程模型
吸收用户级和内核级线程模型的优点

## 2. go并发模型
go并发模型是`GPM`  

每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。这个固定大小的栈同时很大又很小。因为2MB的栈对于一个小小的goroutine来说是很大的内存浪费，而对于一些复杂的任务（如深度嵌套的递归）来说又显得太小。因此，Go语言做了它自己的『线程』。

在Go语言中，每一个goroutine是一个独立的执行单元，相较于每个OS线程固定分配2M内存的模式，goroutine的栈采取了动态扩容方式， 初始时仅为2KB，随着任务执行按需增长，最大可达1GB（64位机器最大是1G，32位机器最大是256M），且完全由golang自己的调度器 Go Scheduler 来调度。此外，GC还会周期性地将不再使用的内存回收，收缩栈空间。

任何用户线程最终肯定都是要交由OS线程来执行的，goroutine（称为G）也不例外，但是G并不直接绑定OS线程运行，而是由Goroutine Scheduler中的 P - Logical Processor （逻辑处理器）来作为两者的『中介』

## 3. GPM模型
- P: 可以看作是一个抽象的资源或者一个上下文，一个P绑定一个OS线程
- M: 把OS线程抽象成一个数据结构
- G: goroutine单元
M通过P调度G执行,P为G提供了运行所需的一切资源和环境,因此在G看来P就是运行它的 “CPU”,,P的数量由用户设置的GOMAXPROCS决定  
![https://segmentfault.com/img/remote/1460000015464892?w=506&h=409](https://segmentfault.com/img/remote/1460000015464892?w=506&h=409)  
当通过go关键字创建一个新的goroutine的时候，它会优先被放入P的本地队列。为了运行goroutine，M需要持有（绑定）一个P，接着M会启动一个OS线程，循环从P的本地队列里取出一个goroutine并执行。当然还有上文提及的 work-stealing调度算法：当M执行完了当前P的Local队列里的所有G后，P也不会就这么在那躺尸啥都不干，它会先尝试从Global队列寻找G来执行，如果Global队列为空，它会随机挑选另外一个P，从它的队列里中拿走一半的G到自己的队列中执行。