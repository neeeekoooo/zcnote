# go垃圾回收gc机制
> 对不再使用的内存资源进行自动回收的功能就被称为垃圾回收

## 参考
- http://legendtkl.com/2017/04/28/golang-gc/
- https://segmentfault.com/a/1190000018161588

## 常用的垃圾回收方法
### 引用计数 reference counting
在一个对象上增加一个被引用次数的计数,当自己被其他对象引用时,计数加1,引用自己的对象被回收时,计数减1,这种方式简单,回收速度快,但是有缺点:
- 需要额外空间存放计数
- 无法处理循环引用,例如a.b=b,b.a=a
- 频繁更新计数减低性能

### 标记清除
- 标记从root开始迭代遍历所有可达的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；
- 标记完成后进行清除操作，对没有标记过的内存进行回收
#### 缺点:
- 内存单元不会在变成垃圾时立刻回收,直到到达某个阈值或者固定时间长度
- 进行垃圾回收时,系统会挂起用户程序，也就是 STW

### 复制收集
### 分代收集 
### 三色标记法
**三色标记的一个明显好处是能够让用户程序和 mark 并发的进行**,,它可以理解为有3个桶
- 第一个桶存放所有对象,标记为白色
- 第二个桶存放第一次被标记的对象,需要检测它可能引用其他对象的,下次会将这些其他对象存放到第二个桶,标记为灰色
- 第三个桶存放已经确定不能被回收的对象
- 一直重复第二个桶,知道第二桶为空
- 剩下第一个桶就是没有被引用的,可以被删掉的
![https://segmentfault.com/img/remote/1460000018161591](https://segmentfault.com/img/remote/1460000018161591)

## go垃圾回收
golang有两种方式垃圾回收,一种是主动回收,一种是手动回收(通过调用` runtime.GC()`,这是阻塞操作),它经历了以下版本的优化
- - v1.3以前版本 STW（Stop The World）
- v1.3 Mark STW, Sweep 并行
- v1.5 三色标记法
- v1.8 混合写屏障（hybrid write barrier）
为什么有写屏障,对于和用户程序并发运行的垃圾回收算法，用户程序会一直修改内存，所以需要记录下来。

## 如何减少gc,提高效率
来源:https://www.golangtc.com/t/559c7ae9b09ecc22f6000005
- GC就是垃圾回收.
- 减少GC最最最有效的办法, 就是减少垃圾的产生.
- 要减少垃圾, 常见的方法:对象池, pool.
- 内存复用, 自己申请一大块内存, 然后手动管理, 实现循环利用. 经常以[]byte, buffer的形式存在.
- 细致的设计, 尽量少new一些短生命周期的对象.
- 减少内存复制, string和[]byte的一些细节.

